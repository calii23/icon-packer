#!/usr/bin/env node
if (process.argv.length !== 3) {
    console.error(`Usage: node ${__filename} [config_file]`);
    process.exit(-1);
}
const configFile = process.argv[2];

const {readFileSync, readdirSync, createReadStream, createWriteStream, existsSync} = require('fs');
const {join, parse} = require('path');
const {convert} = require('./converter');
const toConstantCase = require('to-constant-case');
const mkdirs = require('mkdirs');

if (!existsSync(configFile)) {
    console.error(`${configFile}: file not found`);
    process.exit(255);
}

const config = JSON.parse(readFileSync(configFile).toString());

const {
    iconsDir,
    distDir,
    setName,
    iconSize,
    padding,
    iconsFileName,
    targetProjectRoot
} = config;

const configDir = parse(configFile).dir;

let enumFileExtension;
let sourcesDirectory;

const enumLanguage = config.enum.language;

if (enumLanguage === 'java') {
    enumFileExtension = '.java';
    sourcesDirectory = 'java';
} else if (enumLanguage === 'kotlin') {
    enumFileExtension = '.kt';
    sourcesDirectory = 'kotlin';
} else {
    console.error('Unsupported language:', enumLanguage);
    process.exit(2);
}

const numberPrefixNames = [
    'ZERO_',
    'ONE',
    'TWO_',
    'THREE_',
    'FOUR_',
    'FIVE_',
    'SIX_',
    'SEVEN_',
    'EIGHT_',
    'NINE_'
];

Object.defineProperty(String.prototype, 'replaceAll', {
    value(search, replacement) {
        let last;
        let current = this;
        while (current !== last) {
            last = current;
            current = current.replace(search, replacement);
        }
        return current;
    }
});

mkdirs(join(configDir, distDir));

let icons = readdirSync(join(configDir, iconsDir));
console.log(`found ${icons.length} icons`);

let enumClassFile = join(configDir, distDir, config.enum.className + enumFileExtension);
let iconsFile = join(configDir, distDir, iconsFileName);
let enumClassStream = createWriteStream(enumClassFile);
let iconSetStream = createWriteStream(iconsFile);

let interfaceNames = config.enum.interfaces.map(fullName => fullName.substring(fullName.lastIndexOf('.') + 1));

let imports = [];
if (config.enum.createFunctionName) {
    imports.push('com.vaadin.flow.component.icon.Icon');
}
imports = imports.concat(config.enum.interfaces.filter(fullName => fullName.substring(0, fullName.lastIndexOf('.')) !== config.enum.package));

if (enumLanguage === 'java') {
    enumClassStream.write(`// DO NOT EDIT THIS FILE!
// This file was generated by icon-packer. To update your icon set
// run the icon-packer script again.
package ${config.enum.package};${imports.length ? '\n' + imports.map(fullName => '\nimport ' + fullName + ';').join('') : ''}

/**
 * Generated on ${formatDate(new Date())}
 */
public enum ${config.enum.className}{config.enum.interfaces.length ? \` implements ${interfaceNames.join(', ')}\` : ''} {
`);
} else if (enumLanguage === 'kotlin') {
    enumClassStream.write(`// DO NOT EDIT THIS FILE!
// This file was generated by icon-packer. To update your icon set
// run the icon-packer script again.
package ${config.enum.package}${imports.length ? '\n' + imports.map(fullName => '\nimport ' + fullName).join('') : ''}

/**
 * Generated on ${formatDate(new Date())}
 */
enum class ${config.enum.className}(val iconName: String)${config.enum.interfaces.length ? `: ${interfaceNames.join(', ')}` : ''} {
`);
}

iconSetStream.write(`<iron-iconset-svg name="${setName}" size="${iconSize}"><svg><defs>`);

let start = new Date().getTime();

for (let i = 0; i < icons.length; i++) {
    let iconFile = icons[i];
    let icon = parse(iconFile).name;
    process.stdout.write('\033[2Kprocessing icon (' + (i + 1) + '/' + icons.length + '): ' + icon + '\r');
    let constantName = toConstantCase(icon);
    if (constantName.charCodeAt(0) >= 0x30 && constantName.charCodeAt(0) <= 0x39) {
        constantName = numberPrefixNames[parseInt(constantName[0])] + constantName.substring(1);
    }
    enumClassStream.write(`    ${constantName}("${icon}")`);
    if (i !== icons.length - 1) {
        enumClassStream.write(',\n');
    } else {
        enumClassStream.write(';\n');
    }
    let rawIconData = readFileSync(join(configDir, iconsDir, iconFile)).toString();
    iconSetStream.write(`<g id="${icon}">`);
    convert(rawIconData, iconSetStream, padding, iconSize, icon);
    iconSetStream.write('</g>');
}

let time = new Date().getTime() - start;
console.log(`processed ${icons.length} icons in ${time}ms (${(time / icons.length).toFixed(3)}ms per icon)`);

iconSetStream.write('</defs></svg></iron-iconset-svg>');

if (enumLanguage === 'java') {
    enumClassStream.write(`
    private final String iconName;

    ${config.enum.className}(String iconName) {
        this.iconName = iconName;
    }

    public String getIconName() {
        return this.iconName;
    }`);
    if (config.enum.createFunctionName) {
        enumClassStream.write(`
    ${config.enum.overrideCreate ? '@Override\n' : ''}public Icon ${config.enum.createFunctionName}() {
        return new Icon("${setName}", this.iconName);
    }`);
    }
    enumClassStream.write('}\n');
} else if (enumLanguage === 'kotlin') {
    if (config.enum.createFunctionName) {
        enumClassStream.write(`
    ${config.enum.overrideCreate ? 'override ' : ''}fun ${config.enum.createFunctionName}() = Icon("${setName}", this.iconName)
`);
    }
    enumClassStream.write('}\n');
}

enumClassStream.end();
iconSetStream.end();

if (targetProjectRoot) {
    let enumClassDestinationDir = join(configDir, targetProjectRoot, 'src', 'main', sourcesDirectory, config.enum.package.replaceAll('.', '/'));
    let enumClassDestination = join(enumClassDestinationDir, config.enum.className + enumFileExtension);
    let iconsDestinationDir = join(configDir, targetProjectRoot, 'src', 'main', 'resources', 'static', 'frontend');
    let iconsDestination = join(iconsDestinationDir, iconsFileName);
    mkdirs(enumClassDestinationDir);
    mkdirs(iconsDestinationDir);
    copySync(enumClassFile, enumClassDestination);
    copySync(iconsFile, iconsDestination);
}

function copySync(from, to) {
    createReadStream(from).pipe(createWriteStream(to))
}

function formatDate(date) {
    let year = date.getFullYear().toString();
    let month = (date.getMonth() + 1).toString();
    let day = date.getDate().toString();
    if (month.length === 1)
        month = '0' + month;
    if (day.length === 1)
        day = '0' + day;
    return `${year}-${month}-${day}`
}
